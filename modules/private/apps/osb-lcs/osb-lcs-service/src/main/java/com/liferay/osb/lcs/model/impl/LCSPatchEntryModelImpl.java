/**
 * Copyright (c) 2000-present Liferay, Inc. All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 */

package com.liferay.osb.lcs.model.impl;

import aQute.bnd.annotation.ProviderType;

import com.liferay.expando.kernel.model.ExpandoBridge;
import com.liferay.expando.kernel.util.ExpandoBridgeFactoryUtil;

import com.liferay.osb.lcs.model.LCSPatchEntry;
import com.liferay.osb.lcs.model.LCSPatchEntryModel;

import com.liferay.portal.kernel.bean.AutoEscapeBeanHandler;
import com.liferay.portal.kernel.model.CacheModel;
import com.liferay.portal.kernel.model.impl.BaseModelImpl;
import com.liferay.portal.kernel.service.ServiceContext;
import com.liferay.portal.kernel.util.GetterUtil;
import com.liferay.portal.kernel.util.ProxyUtil;
import com.liferay.portal.kernel.util.StringBundler;
import com.liferay.portal.kernel.util.StringPool;

import java.io.Serializable;

import java.sql.Types;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * The base model implementation for the LCSPatchEntry service. Represents a row in the &quot;OSBLCS_LCSPatchEntry&quot; database table, with each column mapped to a property of this class.
 *
 * <p>
 * This implementation and its corresponding interface {@link LCSPatchEntryModel} exist only as a container for the default property accessors generated by ServiceBuilder. Helper methods and all application logic should be put in {@link LCSPatchEntryImpl}.
 * </p>
 *
 * @author Igor Beslic
 * @see LCSPatchEntryImpl
 * @see LCSPatchEntry
 * @see LCSPatchEntryModel
 * @generated
 */
@ProviderType
public class LCSPatchEntryModelImpl extends BaseModelImpl<LCSPatchEntry>
	implements LCSPatchEntryModel {
	/*
	 * NOTE FOR DEVELOPERS:
	 *
	 * Never modify or reference this class directly. All methods that expect a l c s patch entry model instance should use the {@link LCSPatchEntry} interface instead.
	 */
	public static final String TABLE_NAME = "OSBLCS_LCSPatchEntry";
	public static final Object[][] TABLE_COLUMNS = {
			{ "lcsPatchEntryId", Types.BIGINT },
			{ "patchId", Types.VARCHAR },
			{ "name", Types.VARCHAR },
			{ "description", Types.VARCHAR },
			{ "patchingToolVersion", Types.INTEGER },
			{ "incremental", Types.BOOLEAN },
			{ "singular", Types.BOOLEAN },
			{ "version", Types.INTEGER },
			{ "size_", Types.BIGINT },
			{ "rank", Types.BIGINT },
			{ "requirements", Types.VARCHAR },
			{ "component", Types.VARCHAR },
			{ "compatibleBuild", Types.VARCHAR },
			{ "product", Types.VARCHAR },
			{ "fixedIssues", Types.VARCHAR },
			{ "moduleName", Types.VARCHAR },
			{ "moduleId", Types.VARCHAR },
			{ "tunnelWeb", Types.BOOLEAN },
			{ "buildDate", Types.TIMESTAMP },
			{ "builtFor", Types.VARCHAR }
		};
	public static final Map<String, Integer> TABLE_COLUMNS_MAP = new HashMap<String, Integer>();

	static {
		TABLE_COLUMNS_MAP.put("lcsPatchEntryId", Types.BIGINT);
		TABLE_COLUMNS_MAP.put("patchId", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("name", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("description", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("patchingToolVersion", Types.INTEGER);
		TABLE_COLUMNS_MAP.put("incremental", Types.BOOLEAN);
		TABLE_COLUMNS_MAP.put("singular", Types.BOOLEAN);
		TABLE_COLUMNS_MAP.put("version", Types.INTEGER);
		TABLE_COLUMNS_MAP.put("size_", Types.BIGINT);
		TABLE_COLUMNS_MAP.put("rank", Types.BIGINT);
		TABLE_COLUMNS_MAP.put("requirements", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("component", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("compatibleBuild", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("product", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("fixedIssues", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("moduleName", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("moduleId", Types.VARCHAR);
		TABLE_COLUMNS_MAP.put("tunnelWeb", Types.BOOLEAN);
		TABLE_COLUMNS_MAP.put("buildDate", Types.TIMESTAMP);
		TABLE_COLUMNS_MAP.put("builtFor", Types.VARCHAR);
	}

	public static final String TABLE_SQL_CREATE = "create table OSBLCS_LCSPatchEntry (lcsPatchEntryId LONG not null primary key,patchId VARCHAR(75) null,name VARCHAR(75) null,description VARCHAR(75) null,patchingToolVersion INTEGER,incremental BOOLEAN,singular BOOLEAN,version INTEGER,size_ LONG,rank LONG,requirements VARCHAR(75) null,component VARCHAR(75) null,compatibleBuild VARCHAR(75) null,product VARCHAR(75) null,fixedIssues VARCHAR(75) null,moduleName VARCHAR(75) null,moduleId VARCHAR(75) null,tunnelWeb BOOLEAN,buildDate DATE null,builtFor VARCHAR(75) null)";
	public static final String TABLE_SQL_DROP = "drop table OSBLCS_LCSPatchEntry";
	public static final String ORDER_BY_JPQL = " ORDER BY lcsPatchEntry.lcsPatchEntryId ASC";
	public static final String ORDER_BY_SQL = " ORDER BY OSBLCS_LCSPatchEntry.lcsPatchEntryId ASC";
	public static final String DATA_SOURCE = "liferayDataSource";
	public static final String SESSION_FACTORY = "liferaySessionFactory";
	public static final String TX_MANAGER = "liferayTransactionManager";
	public static final boolean ENTITY_CACHE_ENABLED = GetterUtil.getBoolean(com.liferay.osb.lcs.service.util.ServiceProps.get(
				"value.object.entity.cache.enabled.com.liferay.osb.lcs.model.LCSPatchEntry"),
			true);
	public static final boolean FINDER_CACHE_ENABLED = GetterUtil.getBoolean(com.liferay.osb.lcs.service.util.ServiceProps.get(
				"value.object.finder.cache.enabled.com.liferay.osb.lcs.model.LCSPatchEntry"),
			true);
	public static final boolean COLUMN_BITMASK_ENABLED = GetterUtil.getBoolean(com.liferay.osb.lcs.service.util.ServiceProps.get(
				"value.object.column.bitmask.enabled.com.liferay.osb.lcs.model.LCSPatchEntry"),
			true);
	public static final long PATCHID_COLUMN_BITMASK = 1L;
	public static final long PATCHINGTOOLVERSION_COLUMN_BITMASK = 2L;
	public static final long PRODUCT_COLUMN_BITMASK = 4L;
	public static final long LCSPATCHENTRYID_COLUMN_BITMASK = 8L;
	public static final long LOCK_EXPIRATION_TIME = GetterUtil.getLong(com.liferay.osb.lcs.service.util.ServiceProps.get(
				"lock.expiration.time.com.liferay.osb.lcs.model.LCSPatchEntry"));

	public LCSPatchEntryModelImpl() {
	}

	@Override
	public long getPrimaryKey() {
		return _lcsPatchEntryId;
	}

	@Override
	public void setPrimaryKey(long primaryKey) {
		setLcsPatchEntryId(primaryKey);
	}

	@Override
	public Serializable getPrimaryKeyObj() {
		return _lcsPatchEntryId;
	}

	@Override
	public void setPrimaryKeyObj(Serializable primaryKeyObj) {
		setPrimaryKey(((Long)primaryKeyObj).longValue());
	}

	@Override
	public Class<?> getModelClass() {
		return LCSPatchEntry.class;
	}

	@Override
	public String getModelClassName() {
		return LCSPatchEntry.class.getName();
	}

	@Override
	public Map<String, Object> getModelAttributes() {
		Map<String, Object> attributes = new HashMap<String, Object>();

		attributes.put("lcsPatchEntryId", getLcsPatchEntryId());
		attributes.put("patchId", getPatchId());
		attributes.put("name", getName());
		attributes.put("description", getDescription());
		attributes.put("patchingToolVersion", getPatchingToolVersion());
		attributes.put("incremental", getIncremental());
		attributes.put("singular", getSingular());
		attributes.put("version", getVersion());
		attributes.put("size", getSize());
		attributes.put("rank", getRank());
		attributes.put("requirements", getRequirements());
		attributes.put("component", getComponent());
		attributes.put("compatibleBuild", getCompatibleBuild());
		attributes.put("product", getProduct());
		attributes.put("fixedIssues", getFixedIssues());
		attributes.put("moduleName", getModuleName());
		attributes.put("moduleId", getModuleId());
		attributes.put("tunnelWeb", getTunnelWeb());
		attributes.put("buildDate", getBuildDate());
		attributes.put("builtFor", getBuiltFor());

		attributes.put("entityCacheEnabled", isEntityCacheEnabled());
		attributes.put("finderCacheEnabled", isFinderCacheEnabled());

		return attributes;
	}

	@Override
	public void setModelAttributes(Map<String, Object> attributes) {
		Long lcsPatchEntryId = (Long)attributes.get("lcsPatchEntryId");

		if (lcsPatchEntryId != null) {
			setLcsPatchEntryId(lcsPatchEntryId);
		}

		String patchId = (String)attributes.get("patchId");

		if (patchId != null) {
			setPatchId(patchId);
		}

		String name = (String)attributes.get("name");

		if (name != null) {
			setName(name);
		}

		String description = (String)attributes.get("description");

		if (description != null) {
			setDescription(description);
		}

		Integer patchingToolVersion = (Integer)attributes.get(
				"patchingToolVersion");

		if (patchingToolVersion != null) {
			setPatchingToolVersion(patchingToolVersion);
		}

		Boolean incremental = (Boolean)attributes.get("incremental");

		if (incremental != null) {
			setIncremental(incremental);
		}

		Boolean singular = (Boolean)attributes.get("singular");

		if (singular != null) {
			setSingular(singular);
		}

		Integer version = (Integer)attributes.get("version");

		if (version != null) {
			setVersion(version);
		}

		Long size = (Long)attributes.get("size");

		if (size != null) {
			setSize(size);
		}

		Long rank = (Long)attributes.get("rank");

		if (rank != null) {
			setRank(rank);
		}

		String requirements = (String)attributes.get("requirements");

		if (requirements != null) {
			setRequirements(requirements);
		}

		String component = (String)attributes.get("component");

		if (component != null) {
			setComponent(component);
		}

		String compatibleBuild = (String)attributes.get("compatibleBuild");

		if (compatibleBuild != null) {
			setCompatibleBuild(compatibleBuild);
		}

		String product = (String)attributes.get("product");

		if (product != null) {
			setProduct(product);
		}

		String fixedIssues = (String)attributes.get("fixedIssues");

		if (fixedIssues != null) {
			setFixedIssues(fixedIssues);
		}

		String moduleName = (String)attributes.get("moduleName");

		if (moduleName != null) {
			setModuleName(moduleName);
		}

		String moduleId = (String)attributes.get("moduleId");

		if (moduleId != null) {
			setModuleId(moduleId);
		}

		Boolean tunnelWeb = (Boolean)attributes.get("tunnelWeb");

		if (tunnelWeb != null) {
			setTunnelWeb(tunnelWeb);
		}

		Date buildDate = (Date)attributes.get("buildDate");

		if (buildDate != null) {
			setBuildDate(buildDate);
		}

		String builtFor = (String)attributes.get("builtFor");

		if (builtFor != null) {
			setBuiltFor(builtFor);
		}
	}

	@Override
	public long getLcsPatchEntryId() {
		return _lcsPatchEntryId;
	}

	@Override
	public void setLcsPatchEntryId(long lcsPatchEntryId) {
		_lcsPatchEntryId = lcsPatchEntryId;
	}

	@Override
	public String getPatchId() {
		if (_patchId == null) {
			return StringPool.BLANK;
		}
		else {
			return _patchId;
		}
	}

	@Override
	public void setPatchId(String patchId) {
		_columnBitmask |= PATCHID_COLUMN_BITMASK;

		if (_originalPatchId == null) {
			_originalPatchId = _patchId;
		}

		_patchId = patchId;
	}

	public String getOriginalPatchId() {
		return GetterUtil.getString(_originalPatchId);
	}

	@Override
	public String getName() {
		if (_name == null) {
			return StringPool.BLANK;
		}
		else {
			return _name;
		}
	}

	@Override
	public void setName(String name) {
		_name = name;
	}

	@Override
	public String getDescription() {
		if (_description == null) {
			return StringPool.BLANK;
		}
		else {
			return _description;
		}
	}

	@Override
	public void setDescription(String description) {
		_description = description;
	}

	@Override
	public int getPatchingToolVersion() {
		return _patchingToolVersion;
	}

	@Override
	public void setPatchingToolVersion(int patchingToolVersion) {
		_columnBitmask |= PATCHINGTOOLVERSION_COLUMN_BITMASK;

		if (!_setOriginalPatchingToolVersion) {
			_setOriginalPatchingToolVersion = true;

			_originalPatchingToolVersion = _patchingToolVersion;
		}

		_patchingToolVersion = patchingToolVersion;
	}

	public int getOriginalPatchingToolVersion() {
		return _originalPatchingToolVersion;
	}

	@Override
	public boolean getIncremental() {
		return _incremental;
	}

	@Override
	public boolean isIncremental() {
		return _incremental;
	}

	@Override
	public void setIncremental(boolean incremental) {
		_incremental = incremental;
	}

	@Override
	public boolean getSingular() {
		return _singular;
	}

	@Override
	public boolean isSingular() {
		return _singular;
	}

	@Override
	public void setSingular(boolean singular) {
		_singular = singular;
	}

	@Override
	public int getVersion() {
		return _version;
	}

	@Override
	public void setVersion(int version) {
		_version = version;
	}

	@Override
	public long getSize() {
		return _size;
	}

	@Override
	public void setSize(long size) {
		_size = size;
	}

	@Override
	public long getRank() {
		return _rank;
	}

	@Override
	public void setRank(long rank) {
		_rank = rank;
	}

	@Override
	public String getRequirements() {
		if (_requirements == null) {
			return StringPool.BLANK;
		}
		else {
			return _requirements;
		}
	}

	@Override
	public void setRequirements(String requirements) {
		_requirements = requirements;
	}

	@Override
	public String getComponent() {
		if (_component == null) {
			return StringPool.BLANK;
		}
		else {
			return _component;
		}
	}

	@Override
	public void setComponent(String component) {
		_component = component;
	}

	@Override
	public String getCompatibleBuild() {
		if (_compatibleBuild == null) {
			return StringPool.BLANK;
		}
		else {
			return _compatibleBuild;
		}
	}

	@Override
	public void setCompatibleBuild(String compatibleBuild) {
		_compatibleBuild = compatibleBuild;
	}

	@Override
	public String getProduct() {
		if (_product == null) {
			return StringPool.BLANK;
		}
		else {
			return _product;
		}
	}

	@Override
	public void setProduct(String product) {
		_columnBitmask |= PRODUCT_COLUMN_BITMASK;

		if (_originalProduct == null) {
			_originalProduct = _product;
		}

		_product = product;
	}

	public String getOriginalProduct() {
		return GetterUtil.getString(_originalProduct);
	}

	@Override
	public String getFixedIssues() {
		if (_fixedIssues == null) {
			return StringPool.BLANK;
		}
		else {
			return _fixedIssues;
		}
	}

	@Override
	public void setFixedIssues(String fixedIssues) {
		_fixedIssues = fixedIssues;
	}

	@Override
	public String getModuleName() {
		if (_moduleName == null) {
			return StringPool.BLANK;
		}
		else {
			return _moduleName;
		}
	}

	@Override
	public void setModuleName(String moduleName) {
		_moduleName = moduleName;
	}

	@Override
	public String getModuleId() {
		if (_moduleId == null) {
			return StringPool.BLANK;
		}
		else {
			return _moduleId;
		}
	}

	@Override
	public void setModuleId(String moduleId) {
		_moduleId = moduleId;
	}

	@Override
	public boolean getTunnelWeb() {
		return _tunnelWeb;
	}

	@Override
	public boolean isTunnelWeb() {
		return _tunnelWeb;
	}

	@Override
	public void setTunnelWeb(boolean tunnelWeb) {
		_tunnelWeb = tunnelWeb;
	}

	@Override
	public Date getBuildDate() {
		return _buildDate;
	}

	@Override
	public void setBuildDate(Date buildDate) {
		_buildDate = buildDate;
	}

	@Override
	public String getBuiltFor() {
		if (_builtFor == null) {
			return StringPool.BLANK;
		}
		else {
			return _builtFor;
		}
	}

	@Override
	public void setBuiltFor(String builtFor) {
		_builtFor = builtFor;
	}

	public long getColumnBitmask() {
		return _columnBitmask;
	}

	@Override
	public ExpandoBridge getExpandoBridge() {
		return ExpandoBridgeFactoryUtil.getExpandoBridge(0,
			LCSPatchEntry.class.getName(), getPrimaryKey());
	}

	@Override
	public void setExpandoBridgeAttributes(ServiceContext serviceContext) {
		ExpandoBridge expandoBridge = getExpandoBridge();

		expandoBridge.setAttributes(serviceContext);
	}

	@Override
	public LCSPatchEntry toEscapedModel() {
		if (_escapedModel == null) {
			_escapedModel = (LCSPatchEntry)ProxyUtil.newProxyInstance(_classLoader,
					_escapedModelInterfaces, new AutoEscapeBeanHandler(this));
		}

		return _escapedModel;
	}

	@Override
	public Object clone() {
		LCSPatchEntryImpl lcsPatchEntryImpl = new LCSPatchEntryImpl();

		lcsPatchEntryImpl.setLcsPatchEntryId(getLcsPatchEntryId());
		lcsPatchEntryImpl.setPatchId(getPatchId());
		lcsPatchEntryImpl.setName(getName());
		lcsPatchEntryImpl.setDescription(getDescription());
		lcsPatchEntryImpl.setPatchingToolVersion(getPatchingToolVersion());
		lcsPatchEntryImpl.setIncremental(getIncremental());
		lcsPatchEntryImpl.setSingular(getSingular());
		lcsPatchEntryImpl.setVersion(getVersion());
		lcsPatchEntryImpl.setSize(getSize());
		lcsPatchEntryImpl.setRank(getRank());
		lcsPatchEntryImpl.setRequirements(getRequirements());
		lcsPatchEntryImpl.setComponent(getComponent());
		lcsPatchEntryImpl.setCompatibleBuild(getCompatibleBuild());
		lcsPatchEntryImpl.setProduct(getProduct());
		lcsPatchEntryImpl.setFixedIssues(getFixedIssues());
		lcsPatchEntryImpl.setModuleName(getModuleName());
		lcsPatchEntryImpl.setModuleId(getModuleId());
		lcsPatchEntryImpl.setTunnelWeb(getTunnelWeb());
		lcsPatchEntryImpl.setBuildDate(getBuildDate());
		lcsPatchEntryImpl.setBuiltFor(getBuiltFor());

		lcsPatchEntryImpl.resetOriginalValues();

		return lcsPatchEntryImpl;
	}

	@Override
	public int compareTo(LCSPatchEntry lcsPatchEntry) {
		long primaryKey = lcsPatchEntry.getPrimaryKey();

		if (getPrimaryKey() < primaryKey) {
			return -1;
		}
		else if (getPrimaryKey() > primaryKey) {
			return 1;
		}
		else {
			return 0;
		}
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}

		if (!(obj instanceof LCSPatchEntry)) {
			return false;
		}

		LCSPatchEntry lcsPatchEntry = (LCSPatchEntry)obj;

		long primaryKey = lcsPatchEntry.getPrimaryKey();

		if (getPrimaryKey() == primaryKey) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public int hashCode() {
		return (int)getPrimaryKey();
	}

	@Override
	public boolean isEntityCacheEnabled() {
		return ENTITY_CACHE_ENABLED;
	}

	@Override
	public boolean isFinderCacheEnabled() {
		return FINDER_CACHE_ENABLED;
	}

	@Override
	public void resetOriginalValues() {
		LCSPatchEntryModelImpl lcsPatchEntryModelImpl = this;

		lcsPatchEntryModelImpl._originalPatchId = lcsPatchEntryModelImpl._patchId;

		lcsPatchEntryModelImpl._originalPatchingToolVersion = lcsPatchEntryModelImpl._patchingToolVersion;

		lcsPatchEntryModelImpl._setOriginalPatchingToolVersion = false;

		lcsPatchEntryModelImpl._originalProduct = lcsPatchEntryModelImpl._product;

		lcsPatchEntryModelImpl._columnBitmask = 0;
	}

	@Override
	public CacheModel<LCSPatchEntry> toCacheModel() {
		LCSPatchEntryCacheModel lcsPatchEntryCacheModel = new LCSPatchEntryCacheModel();

		lcsPatchEntryCacheModel.lcsPatchEntryId = getLcsPatchEntryId();

		lcsPatchEntryCacheModel.patchId = getPatchId();

		String patchId = lcsPatchEntryCacheModel.patchId;

		if ((patchId != null) && (patchId.length() == 0)) {
			lcsPatchEntryCacheModel.patchId = null;
		}

		lcsPatchEntryCacheModel.name = getName();

		String name = lcsPatchEntryCacheModel.name;

		if ((name != null) && (name.length() == 0)) {
			lcsPatchEntryCacheModel.name = null;
		}

		lcsPatchEntryCacheModel.description = getDescription();

		String description = lcsPatchEntryCacheModel.description;

		if ((description != null) && (description.length() == 0)) {
			lcsPatchEntryCacheModel.description = null;
		}

		lcsPatchEntryCacheModel.patchingToolVersion = getPatchingToolVersion();

		lcsPatchEntryCacheModel.incremental = getIncremental();

		lcsPatchEntryCacheModel.singular = getSingular();

		lcsPatchEntryCacheModel.version = getVersion();

		lcsPatchEntryCacheModel.size = getSize();

		lcsPatchEntryCacheModel.rank = getRank();

		lcsPatchEntryCacheModel.requirements = getRequirements();

		String requirements = lcsPatchEntryCacheModel.requirements;

		if ((requirements != null) && (requirements.length() == 0)) {
			lcsPatchEntryCacheModel.requirements = null;
		}

		lcsPatchEntryCacheModel.component = getComponent();

		String component = lcsPatchEntryCacheModel.component;

		if ((component != null) && (component.length() == 0)) {
			lcsPatchEntryCacheModel.component = null;
		}

		lcsPatchEntryCacheModel.compatibleBuild = getCompatibleBuild();

		String compatibleBuild = lcsPatchEntryCacheModel.compatibleBuild;

		if ((compatibleBuild != null) && (compatibleBuild.length() == 0)) {
			lcsPatchEntryCacheModel.compatibleBuild = null;
		}

		lcsPatchEntryCacheModel.product = getProduct();

		String product = lcsPatchEntryCacheModel.product;

		if ((product != null) && (product.length() == 0)) {
			lcsPatchEntryCacheModel.product = null;
		}

		lcsPatchEntryCacheModel.fixedIssues = getFixedIssues();

		String fixedIssues = lcsPatchEntryCacheModel.fixedIssues;

		if ((fixedIssues != null) && (fixedIssues.length() == 0)) {
			lcsPatchEntryCacheModel.fixedIssues = null;
		}

		lcsPatchEntryCacheModel.moduleName = getModuleName();

		String moduleName = lcsPatchEntryCacheModel.moduleName;

		if ((moduleName != null) && (moduleName.length() == 0)) {
			lcsPatchEntryCacheModel.moduleName = null;
		}

		lcsPatchEntryCacheModel.moduleId = getModuleId();

		String moduleId = lcsPatchEntryCacheModel.moduleId;

		if ((moduleId != null) && (moduleId.length() == 0)) {
			lcsPatchEntryCacheModel.moduleId = null;
		}

		lcsPatchEntryCacheModel.tunnelWeb = getTunnelWeb();

		Date buildDate = getBuildDate();

		if (buildDate != null) {
			lcsPatchEntryCacheModel.buildDate = buildDate.getTime();
		}
		else {
			lcsPatchEntryCacheModel.buildDate = Long.MIN_VALUE;
		}

		lcsPatchEntryCacheModel.builtFor = getBuiltFor();

		String builtFor = lcsPatchEntryCacheModel.builtFor;

		if ((builtFor != null) && (builtFor.length() == 0)) {
			lcsPatchEntryCacheModel.builtFor = null;
		}

		return lcsPatchEntryCacheModel;
	}

	@Override
	public String toString() {
		StringBundler sb = new StringBundler(41);

		sb.append("{lcsPatchEntryId=");
		sb.append(getLcsPatchEntryId());
		sb.append(", patchId=");
		sb.append(getPatchId());
		sb.append(", name=");
		sb.append(getName());
		sb.append(", description=");
		sb.append(getDescription());
		sb.append(", patchingToolVersion=");
		sb.append(getPatchingToolVersion());
		sb.append(", incremental=");
		sb.append(getIncremental());
		sb.append(", singular=");
		sb.append(getSingular());
		sb.append(", version=");
		sb.append(getVersion());
		sb.append(", size=");
		sb.append(getSize());
		sb.append(", rank=");
		sb.append(getRank());
		sb.append(", requirements=");
		sb.append(getRequirements());
		sb.append(", component=");
		sb.append(getComponent());
		sb.append(", compatibleBuild=");
		sb.append(getCompatibleBuild());
		sb.append(", product=");
		sb.append(getProduct());
		sb.append(", fixedIssues=");
		sb.append(getFixedIssues());
		sb.append(", moduleName=");
		sb.append(getModuleName());
		sb.append(", moduleId=");
		sb.append(getModuleId());
		sb.append(", tunnelWeb=");
		sb.append(getTunnelWeb());
		sb.append(", buildDate=");
		sb.append(getBuildDate());
		sb.append(", builtFor=");
		sb.append(getBuiltFor());
		sb.append("}");

		return sb.toString();
	}

	@Override
	public String toXmlString() {
		StringBundler sb = new StringBundler(64);

		sb.append("<model><model-name>");
		sb.append("com.liferay.osb.lcs.model.LCSPatchEntry");
		sb.append("</model-name>");

		sb.append(
			"<column><column-name>lcsPatchEntryId</column-name><column-value><![CDATA[");
		sb.append(getLcsPatchEntryId());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>patchId</column-name><column-value><![CDATA[");
		sb.append(getPatchId());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>name</column-name><column-value><![CDATA[");
		sb.append(getName());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>description</column-name><column-value><![CDATA[");
		sb.append(getDescription());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>patchingToolVersion</column-name><column-value><![CDATA[");
		sb.append(getPatchingToolVersion());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>incremental</column-name><column-value><![CDATA[");
		sb.append(getIncremental());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>singular</column-name><column-value><![CDATA[");
		sb.append(getSingular());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>version</column-name><column-value><![CDATA[");
		sb.append(getVersion());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>size</column-name><column-value><![CDATA[");
		sb.append(getSize());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>rank</column-name><column-value><![CDATA[");
		sb.append(getRank());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>requirements</column-name><column-value><![CDATA[");
		sb.append(getRequirements());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>component</column-name><column-value><![CDATA[");
		sb.append(getComponent());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>compatibleBuild</column-name><column-value><![CDATA[");
		sb.append(getCompatibleBuild());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>product</column-name><column-value><![CDATA[");
		sb.append(getProduct());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>fixedIssues</column-name><column-value><![CDATA[");
		sb.append(getFixedIssues());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>moduleName</column-name><column-value><![CDATA[");
		sb.append(getModuleName());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>moduleId</column-name><column-value><![CDATA[");
		sb.append(getModuleId());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>tunnelWeb</column-name><column-value><![CDATA[");
		sb.append(getTunnelWeb());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>buildDate</column-name><column-value><![CDATA[");
		sb.append(getBuildDate());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>builtFor</column-name><column-value><![CDATA[");
		sb.append(getBuiltFor());
		sb.append("]]></column-value></column>");

		sb.append("</model>");

		return sb.toString();
	}

	private static final ClassLoader _classLoader = LCSPatchEntry.class.getClassLoader();
	private static final Class<?>[] _escapedModelInterfaces = new Class[] {
			LCSPatchEntry.class
		};
	private long _lcsPatchEntryId;
	private String _patchId;
	private String _originalPatchId;
	private String _name;
	private String _description;
	private int _patchingToolVersion;
	private int _originalPatchingToolVersion;
	private boolean _setOriginalPatchingToolVersion;
	private boolean _incremental;
	private boolean _singular;
	private int _version;
	private long _size;
	private long _rank;
	private String _requirements;
	private String _component;
	private String _compatibleBuild;
	private String _product;
	private String _originalProduct;
	private String _fixedIssues;
	private String _moduleName;
	private String _moduleId;
	private boolean _tunnelWeb;
	private Date _buildDate;
	private String _builtFor;
	private long _columnBitmask;
	private LCSPatchEntry _escapedModel;
}